
* Introduction

I sometimes get asked something along the lines of


#+begin_quote
What is the single most important package in your emacs config that
makes you more productive?
#+end_quote


* Lever

Levers are great.
They make it possible to have a large effect with little

effort
output with input

* Hello, bash-completion

* async-shell-command and friends


mm/shell-command-on-file


** compilation

** rerun compilation with a single key

** default env for your async shell commands

enter .dir-locals.el

I never remember the syntax to this
Like how it was with `ln` before borkdude shared this trick:
substitute ~ln~ with ~cp~ in your mind and you know the args.

Imagine
you write a list
of function calls
the operation is the mode and is allowed to be nil
the args are variables to set
you write a cons cell in elisp as a dotted list (foo . bar)

And imagine there is a quote around your list





* babashka tasks

I can write build tasks in my favority language clojure, with the
development ergonomics of a lisp.


* read shell command


** history

M-h		consult-history
M-i		completion-at-point
M-n		next-history-element
M-p		previous-history-element

M-r		previous-matching-history-element
M-s		next-matching-history-element



frankly those are not so useful to me because consult-history coverst that
like a powerhose
like a power hose
like a water hydrant hose

M-r		previous-matching-history-element
M-s		next-matching-history-element


** make completions even sicker

Here is a few pieces that make minibuffer completions
bolster
add levarage
make it juicy

I have consult-yank-pop on M-y

hippie
it might sometimes just uncannily know what you where thinking









* compilation

Using emacs ~project.el~ I get a beautiful flow of invoking bb tasks:
I just need a project with a =.git= dir.
And I invoke ~project-compile~, type in ~bb

(defun project-compile ()
  "Run `compile' in the project root."
  (declare (interactive-only compile))
  (interactive)
  (let ((default-directory (project-root (project-current t)))
        (compilation-buffer-name-function
         (or project-compilation-buffer-name-function
             compilation-buffer-name-function)))
    (call-interactively #'compile)))



and ~recompile~


(defun compilation-read-command (command)
  (read-shell-command "Compile command: " command
                      (if (equal (car compile-history) command)
                          '(compile-history . 1)
                        'compile-history)))


it uses compile-history


* It gets even better

Sometimes you want to run the same command over and over.
For example when compiling or devving some script.

Now you might start doing
scm
and the ~C-p~ to go up in the history everytime.


With a recent version of emacs
revert-buffer-function
Lol, so good.


* more levers

a lever
a doorway


* project.el

I decided this does enough

kudos to projectile.el
I was not using emacs at that time for a while yet.
But some digging reveals to me tha projectile.el is the
senior package
older
venerable

project.el  is the new kid on the block
only 7 years old



first commit

[benj@benj-pc projectile]$ git log --reverse | head
commit 4cf61b8cd0099b50c13502c862b4c2e73b59dc01
Author: Bozhidar Batsov <bozhidar.batsov@gmail.com>
Date:   Sun Jul 31 22:12:59 2011 +0300

    initial commit


emacs project.el lisp:

git log --reverse -- ./project.el | head

commit f8c720b55b9419c849ea9febe6f888761a61949b
Author: Dmitry Gutov <dgutov@yandex.ru>
Date:   Fri Jul 10 04:34:41 2015 +0300

    Introduce a Project API

    * lisp/progmodes/project.el: New file.

    * lisp/cedet/ede.el: (project-try-ede): New function.
    (project-root): New implementation.
