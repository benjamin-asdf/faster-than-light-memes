<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bashing is better than extending</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<link rel="stylesheet" href="navbar.css" />
<!-- <script src="navbar_toggle.js"></script> -->
</head>
<body>
<div id="preamble" class="status">
<h4>
    <a href="https://benjamin-asdf.github.io/faster-than-light-memes/"
       style="background-color:black;;text-decoration:none;padding:0.3rem">
      <span style="color:#feb48f">:faster-than-light</span>
      <span style="color:#F689FF">/memes</span>
    </a>
  </h4>
<div>
  <!-- <button id="navbar-toggle">â˜°</button> -->
<ul id="navbar">
    <li><a href="binaural-beats-using-scittle.html">Binaural Beats with Scittle</a></li>
<li><a href="bashing-is-better-than-extending.html">Bashing is better than extending</a></li>
<li><a href="dir-env-process-environment.html">Dir env for process-environment</a></li>
<li><a href="scittle-prints-itself.html">Scittle prints itself</a></li>
<li><a href="intro-to-clojure.html">Intro to Clojure</a></li>
<li><a href="scratching-in-space.html">Scratching in space</a></li>
<li><a href="jacking-nbb.html">Jacking in nbb</a></li>
<li><a href="backing-you-up.html">Backing you up</a></li>
<li><a href="anonymous-commands-in-emacs.html">Anonymous lambdas in emacs binds</a></li>
<li><a href="dreaming-code.html">Dreaming code</a></li>
<li><a href="pearls-of-introspection.html">Pearls of Introspection</a></li>
<li><a href="not-even-the-sky-is-the-limit.html">Not even the Sky is the limit</a></li>
<li><a href="aws-iam-and-cloudwatch-logs-start-query.html">Cloudwatch Logs Query Iam Example</a></li>
<li><a href="the-deeper-chat-gpt.html">The Deeper Chat-Gpt</a></li>

</ul>
 </div>
</div>
<div id="content" class="content">
<h1 class="title">Bashing is better than extending</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga527ab5">Introduction</a></li>
<li><a href="#org29f5625">read-shell-command</a></li>
<li><a href="#orgdd2e3be">bash-completion</a></li>
<li><a href="#orgad710cd">bash completions are now your lever</a>
<ul>
<li><a href="#orgaeea4fc">Babashka tasks</a></li>
</ul>
</li>
<li><a href="#org06a01c7">Commands that leverage <code>read-shell-command</code></a>
<ul>
<li><a href="#org2bb7e5d">shell-command</a>
<ul>
<li><a href="#org84f356b">Here is a nugget:</a></li>
<li><a href="#org3b98c6a">Good to know:</a></li>
<li><a href="#org4350036">Output buffer</a></li>
</ul>
</li>
<li><a href="#org983db20">shell-command-async</a></li>
<li><a href="#orgc6b59d3">compile</a></li>
<li><a href="#orga13b7f2">dired</a></li>
<li><a href="#org276cb08">shell-command-on-file</a></li>
</ul>
</li>
<li><a href="#org57ebadd">It gets even better</a>
<ul>
<li><a href="#org77f7253">revert-buffer in compilation buffers</a></li>
</ul>
</li>
<li><a href="#orgf4d30cd">Scripts at the speed of thought</a>
<ul>
<li><a href="#orgdaaa600">mememacs/create-script</a>
<ul>
<li><a href="#orgc6e837a">bash-completion in <code>sh-mode</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org938b6fe">Oh async-shell-command, my trusted friend</a>
<ul>
<li><a href="#org4a5b32e">Put the command into the buffer name</a></li>
<li><a href="#org6af4de8">shell-command&#x2013;same-buffer-confirm</a></li>
<li><a href="#orgeb0fdcc">shell-mode as a terminal emulator</a></li>
</ul>
</li>
<li><a href="#org8cdf7b7">The next layer on the cake</a>
<ul>
<li><a href="#orgd7dfe46">project</a></li>
<li><a href="#org893f118">recompile</a></li>
<li><a href="#org42fa933">ansi colors for comint</a></li>
</ul>
</li>
<li><a href="#orgdee631b">Levers are great</a>
<ul>
<li><a href="#org2ad29c2">ssh</a></li>
<li><a href="#org47cb68a">embarking</a></li>
<li><a href="#orgfdf96a1">pass</a></li>
</ul>
</li>
<li><a href="#org2ac6f8c">Particulars</a>
<ul>
<li><a href="#org99c2068">shell-file-name</a></li>
<li><a href="#org0e57b16">troubleshoot</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>Not</b> how to run babashka tasks.
</p>

<p>
How <code>bash-completion</code>  makes everything better.
</p>

<p>
How to run <b>any</b> shell commands.
</p>

<p>
Technology around <code>shell-command</code>.
</p>

<p>
Simplicity and joy.
</p>

<div id="outline-container-orga527ab5" class="outline-2">
<h2 id="orga527ab5">Introduction</h2>
<div class="outline-text-2" id="text-orga527ab5">
<p>
Ok, let's just do it. You might want to hold tight to your chair because
the juiciness and elegance of what follow might just blow you over.
Here is how I build my <a href="https://benjamin-asdf.github.io/faster-than-light-memes/">blog</a> with babashka tasks:
</p>


<div id="org05af355" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/bb-task-demo.gif?raw=true" alt="bb-task-demo.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 1: </span>Using <code>compile</code> to leverage <code>read-shell-command</code> and thereby <code>bash-completions</code>. Recompiling via <code>revert-buffer</code>. Dismissing the <code>*compilation*</code> buffer.</p>
</div>

<p>
You might think "Ok sure, looks useful." Let me entice you with the
the really impressive thing about this:
</p>

<p>
There is nothing concrete about babashka tasks nor about that specific
project in my emacs config.
It just works by having a <code>bb.edn</code> with tasks.
</p>

<p>
Made possible via the harmony between some 3 or 4 general tools.
Like layers of ice. You deserve some skates to ride on
it. Smoothly, gracefully and <b>fast</b>.
Here is the story of a happy little package called <code>bash-completion</code>.
</p>
</div>
</div>

<div id="outline-container-org29f5625" class="outline-2">
<h2 id="org29f5625">read-shell-command</h2>
<div class="outline-text-2" id="text-org29f5625">
<p>
This is like <code>read-from-minibuffer</code> but sets some keymap and history.
Hit <code>&lt;tab&gt;</code>, you get completions from <code>shell-dynamic-complete-functions</code>.
Those completions are sort of okay, but they do not give you command-specific completions.
Invoke <code>shell-command</code>, then type <code>git checkout</code>, hit tab. Nothing happens. <b><b>Yet</b></b>.
</p>
</div>
</div>

<div id="outline-container-orgdd2e3be" class="outline-2">
<h2 id="orgdd2e3be">bash-completion</h2>
<div class="outline-text-2" id="text-orgdd2e3be">
<p>
Ok your emacs life is about to level up +1 <a href="https://github.com/szermatt/emacs-bash-completion">bash-completion</a>.
Config:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package bash-completion
  <span style="font-weight: bold;">:init</span> (autoload
          'bash-completion-dynamic-complete
          <span style="font-style: italic;">"bash-completion"</span>
          <span style="font-style: italic;">"BASH completion hook"</span>)
  (add-hook
   'shell-dynamic-complete-functions
   #'bash-completion-dynamic-complete))
</pre>
</div>

<p>
Here are the completions of your shell at the tips of those sweet
coconut oily fingers.
</p>

<p>
Now you can do <code>shell-command</code>
-&gt; Hit that tab while typing <code>git checkout ..</code> a door just
opened.
</p>
</div>
</div>

<div id="outline-container-orgad710cd" class="outline-2">
<h2 id="orgad710cd">bash completions are now your lever</h2>
<div class="outline-text-2" id="text-orgad710cd">
<p>
We have entered the realm of harnessing already existing shell completions directly.
</p>
</div>

<div id="outline-container-orgaeea4fc" class="outline-3">
<h3 id="orgaeea4fc">Babashka tasks</h3>
<div class="outline-text-3" id="text-orgaeea4fc">
<p>
Babashka tasks are one of the great discoveries of our time,
allowing us to write build tasks in Clojure, with the
development ergonomics of a lisp.
</p>

<p>
The babashka book has <a href="https://book.babashka.org/#_terminal_tab_completion">a section</a> on adding shell completions.
Boom. This is all you need.
Now you can enjoy those babashka tasks completions.
</p>
</div>
</div>
</div>

<div id="outline-container-org06a01c7" class="outline-2">
<h2 id="org06a01c7">Commands that leverage <code>read-shell-command</code></h2>
<div class="outline-text-2" id="text-org06a01c7">
<p>
They use <code>read-shell-command</code>.
Making <code>read-shell-command</code> <b>good</b> will pay off for all these.
</p>
</div>

<div id="outline-container-org2bb7e5d" class="outline-3">
<h3 id="org2bb7e5d">shell-command</h3>
<div class="outline-text-3" id="text-org2bb7e5d">
<p>
Bound to <code>M-!</code>
</p>

<p>
This is the <code>interactive</code> doorway into emacs lisp <code>start-process</code> functionality.
</p>
</div>

<div id="outline-container-org84f356b" class="outline-4">
<h4 id="org84f356b">Here is a nugget:</h4>
<div class="outline-text-4" id="text-org84f356b">
<blockquote>
<p>
With prefix argument, insert the COMMAND's output at point.
</p>
</blockquote>

<p>
<code>C-u M-!</code> <code>date</code> and you have a date inserted in the buffer.
</p>

<p>
Like this:
<code>Thu Sep 29 10:55:44 AM CEST 2022</code>
</p>
</div>
</div>

<div id="outline-container-org3b98c6a" class="outline-4">
<h4 id="org3b98c6a">Good to know:</h4>
<div class="outline-text-4" id="text-org3b98c6a">
<blockquote>
<p>
If COMMAND ends in &amp;, execute it asynchronously.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org4350036" class="outline-4">
<h4 id="org4350036">Output buffer</h4>
<div class="outline-text-4" id="text-org4350036">
<p>
Your command output is located by default in a buffer named by <code>shell-command-buffer-name</code>.
Or <code>shell-command-buffer-name-async</code> when async.
</p>
</div>
</div>
</div>

<div id="outline-container-org983db20" class="outline-3">
<h3 id="org983db20">shell-command-async</h3>
<div class="outline-text-3" id="text-org983db20">
<p>
Bound to <code>M-&amp;</code> and has the same effect as adding a <code>&amp;</code> in <code>shell-command</code>.
To kill the process I can hit <code>C-c C-c</code>.
</p>
</div>
</div>

<div id="outline-container-orgc6b59d3" class="outline-3">
<h3 id="orgc6b59d3">compile</h3>
<div class="outline-text-3" id="text-orgc6b59d3">
<p>
Very useful, very similar to <code>shell-command-async</code>.
Always uses the same buffer called <code>*compilation*</code>.
You can set <code>compile-command</code> for instance via <code>.dir-locals.el</code>, then
it auto makes a compile command in that project.
</p>
</div>
</div>

<div id="outline-container-orga13b7f2" class="outline-3">
<h3 id="orga13b7f2">dired</h3>
<div class="outline-text-3" id="text-orga13b7f2">
<p>
<code>dired-do-shell-command</code> and <code>dired-do-async-shell-command</code>
are symetrical with <code>shell-command</code> and <code>async-shell-command</code>.
Those functions call <code>shell-command</code>.
</p>

<p>
Bound to <code>!</code> and <code>&amp;</code> in dired Docstring is worth reading.
Important to know is that <code>*</code> expands to <code>dired-file-name-at-point</code>,
or the marked files, but is implicit as the last arg.
</p>
</div>
</div>

<div id="outline-container-org276cb08" class="outline-3">
<h3 id="org276cb08">shell-command-on-file</h3>
<div class="outline-text-3" id="text-org276cb08">
<p>
Sometimes you are currently visiting a script file and you just want
to run it.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/shell-command-on-file</span> (command)
  <span style="font-style: italic;">"Execute COMMAND asynchronously on the current file."</span>
  (<span style="font-weight: bold;">interactive</span> (list (read-shell-command
                      (concat <span style="font-style: italic;">"Async shell command on "</span> (buffer-name) <span style="font-style: italic;">": "</span>))))
  (<span style="font-weight: bold;">let</span> ((filename (<span style="font-weight: bold;">if</span> (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (async-shell-command (concat command <span style="font-style: italic;">" "</span> filename))))
</pre>
</div>

<p>
Thanks to <a href="https://github.com/Gavinok/emacs.d">Gavin Freeborn</a> for the initial version of this code.
</p>
</div>
</div>
</div>

<div id="outline-container-org57ebadd" class="outline-2">
<h2 id="org57ebadd">It gets even better</h2>
<div class="outline-text-2" id="text-org57ebadd">
<p>
Let me introduce you to the wonders of <code>revert-buffer-function</code>.
Now, <code>revert-buffer</code> is a powerful command by itself.
</p>

<p>
I did not know this for a while, but you can set the local variable <code>revert-buffer-function</code>.
This pearl is in emacs 28:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setq-local</span>
 revert-buffer-function
 (<span style="font-weight: bold;">lambda</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> _)
   (async-shell-command command buffer)))
</pre>
</div>

<p>
You say <code>revert-buffer</code> in a shell command buffer, to boom run the
command again in the same buffer. Exactly what I want sometimes.
A single key to rerun a command. And I think the concepts just fit
nicely. There is no mental burden with this.
</p>
</div>

<div id="outline-container-org77f7253" class="outline-3">
<h3 id="org77f7253">revert-buffer in compilation buffers</h3>
<div class="outline-text-3" id="text-org77f7253">
<div class="org-src-container">
<pre class="src src-elisp">(advice-add
   #'compilation-revert-buffer
   <span style="font-weight: bold;">:filter-args</span>
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/always-noconfirm-compilation-revert-buffer</span> (args)
     (<span style="font-weight: bold;">pcase</span> args
       (`(,ignore-auto nil) `(,ignore-auto t))
       (_ args))))
</pre>
</div>

<p>
I use <code>revert-buffer</code> as a consenting adult - kill and restart the
compile command, without asking.
</p>
</div>
</div>
</div>


<div id="outline-container-orgf4d30cd" class="outline-2">
<h2 id="orgf4d30cd">Scripts at the speed of thought</h2>
<div class="outline-text-2" id="text-orgf4d30cd">

<div id="org1447a8f" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/insta-script.gif?raw=true" alt="insta-script.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 2: </span>Make a script, and run the script. Leveraging <code>bash-completion</code> in <code>shell-script-mode</code>.</p>
</div>
</div>

<div id="outline-container-orgdaaa600" class="outline-3">
<h3 id="orgdaaa600">mememacs/create-script</h3>
<div class="outline-text-3" id="text-orgdaaa600">
<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-script*</span> (file bang setup)
  (find-file file)
  (insert bang)
  (save-buffer)
  (evil-insert-state)
  (set-file-modes file #o751)
  (funcall setup))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-script</span> (file)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"Fnew script: "</span>)
  (mememacs/create-script*
   file
   <span style="font-style: italic;">"#!/bin/sh\n"</span>
   #'shell-script-mode))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-bb-script</span> (file)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"Fnew bb: "</span>)
  (mememacs/create-script*
   file
   <span style="font-style: italic;">"#!/usr/bin/env bb\n"</span>
   #'clojure-mode))
</pre>
</div>

<p>
I have bound these in <code>dired-mode</code>.
Then, I use <code>mm/shell-command-on-file</code> to dev interactively sort of.
</p>

<p>
Btw <code>shell-script-mode</code> becomes a power house when you integrate <a href="https://github.com/koalaman/shellcheck">shellcheck</a>.
<code>flycheck</code> has something for that. (pretty sure <code>flymake</code> should as well.)
Shellcheck makes superb warnings. Firmly in my "adopt" circle.
</p>
</div>

<div id="outline-container-orgc6e837a" class="outline-4">
<h4 id="orgc6e837a">bash-completion in <code>sh-mode</code></h4>
<div class="outline-text-4" id="text-orgc6e837a">
<p>
Here is my full <code>bash-completion</code> config that adds to <code>capf</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package bash-completion
  <span style="font-weight: bold;">:init</span>
  (autoload 'bash-completion-dynamic-complete
    <span style="font-style: italic;">"bash-completion"</span>
    <span style="font-style: italic;">"BASH completion hook"</span>)
  (add-hook 'shell-dynamic-complete-functions
            #'bash-completion-dynamic-complete)

  <span style="font-weight: bold;">:config</span>
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-capf-1</span> (bol)
    (bash-completion-dynamic-complete-nocomint (funcall bol) (point) t))
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-eshell-capf</span> ()
    (bash-completion-capf-1 (<span style="font-weight: bold;">lambda</span> () (<span style="font-weight: bold;">save-excursion</span> (eshell-bol) (point)))))
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-capf</span> ()
    (bash-completion-capf-1 #'point-at-bol))
  (add-hook
   'sh-mode-hook
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/add-bash-completion</span> ()
     (add-hook 'completion-at-point-functions #'bash-completion-capf nil t))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org938b6fe" class="outline-2">
<h2 id="org938b6fe">Oh async-shell-command, my trusted friend</h2>
<div class="outline-text-2" id="text-org938b6fe">
<p>
Of these commands, it is the one I use the most.
The other commands could be performed in terms of it.
Here is some of my journey smoothing out some edges.
</p>
</div>

<div id="outline-container-org4a5b32e" class="outline-3">
<h3 id="org4a5b32e">Put the command into the buffer name</h3>
<div class="outline-text-3" id="text-org4a5b32e">
<p>
When you run a second command, by default, it tries to reuse the old buffer and asks you
</p>

<div class="org-src-container">
<pre class="src src-elisp">(yes-or-no-p
 (format
  <span style="font-style: italic;">"A command is running in the default buffer.  %s? "</span>
  action))
</pre>
</div>

<p>
I put the <code>command</code> into the buffer name so I usually get a unique
buffer name.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/put-command-in-async-buff-name</span> (f <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args)
  (<span style="font-weight: bold;">let*</span> ((path-s (path-slug default-directory))
         (command (car args))
         (buffname (concat path-s <span style="font-style: italic;">" "</span> command))
         (shell-command-buffer-name-async
          (format
           <span style="font-style: italic;">"*async-shell-command %s*"</span>
           (string-trim
            (substring buffname 0 (min (length buffname) 50))))))
    (apply f args)))

(advice-add 'shell-command <span style="font-weight: bold;">:around</span> #'mm/put-command-in-async-buff-name)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">path-slug</span> (dir)
    <span style="font-style: italic;">"Returns the initials of `dir`s path,</span>
<span style="font-style: italic;">with the last part appended fully</span>

<span style="font-style: italic;">Example:</span>

<span style="font-style: italic;">(path-slug \"/foo/bar/hello\")</span>
<span style="font-style: italic;">=&gt; \"f/b/hello\" "</span>
    (<span style="font-weight: bold;">require</span> '<span style="font-weight: bold; text-decoration: underline;">dash</span>)
    (<span style="font-weight: bold;">let*</span> ((path (replace-regexp-in-string <span style="font-style: italic;">"\\."</span> <span style="font-style: italic;">""</span> dir))
           (path (split-string path <span style="font-style: italic;">"/"</span> t))
           (path-s (mapconcat
                    (<span style="font-weight: bold;">lambda</span> (it)
                      (cl-subseq it 0 1))
                    (-drop-last 1 path)
                    <span style="font-style: italic;">"/"</span>))
           (path-s (concat
                    path-s
                    <span style="font-style: italic;">"/"</span>
                    (-last-item path))))
      path-s))
</pre>
</div>

<p>
Now I can complete buffers and start typing the commands.
And the buffers don't have an anonymous name like <code>*async-shell-command&lt;2&gt;*</code>.
</p>
</div>
</div>

<div id="outline-container-org6af4de8" class="outline-3">
<h3 id="org6af4de8">shell-command&#x2013;same-buffer-confirm</h3>
<div class="outline-text-3" id="text-org6af4de8">
<p>
Sort of a power setting when you do <code>async-shell-command</code> a lot.
Nowadays I do:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setf</span> async-shell-command-buffer 'new-buffer)
</pre>
</div>

<p>
If I want to kill I can do <code>C-c C-c</code> on the old buffer.
</p>
</div>
</div>

<div id="outline-container-orgeb0fdcc" class="outline-3">
<h3 id="orgeb0fdcc">shell-mode as a terminal emulator</h3>
<div class="outline-text-3" id="text-orgeb0fdcc">
<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/shell-via-async-shell-command</span> ()
    (switch-to-buffer
     (window-buffer
      (async-shell-command
       shell-file-name))))
</pre>
</div>

<p>
You get a shell buffer running your shell.
Does everything I need from a terminal.
It pays of having a minimal <code>.rc</code> file. This is also why I have
<code>shell-file-name</code> set to "/bin/bash".
Even though I have a cool zsh config with vi mode. I get all emacs editing power in that shell buffer.
</p>
</div>
</div>
</div>

<div id="outline-container-org8cdf7b7" class="outline-2">
<h2 id="org8cdf7b7">The next layer on the cake</h2>
<div class="outline-text-2" id="text-org8cdf7b7">
<p>
More context for <code>shell-command</code>.
</p>
</div>

<div id="outline-container-orgd7dfe46" class="outline-3">
<h3 id="orgd7dfe46">project</h3>
<div class="outline-text-3" id="text-orgd7dfe46">
<p>
I use <code>project.el</code>. <code>project-compile</code>  runs <code>compile</code> in the project root. Analogously, there is <code>project-async-shell-command</code>.
<code>projectile</code>, a big and widely used package, provides similar commands.
</p>
</div>
</div>

<div id="outline-container-org893f118" class="outline-3">
<h3 id="org893f118">recompile</h3>
<div class="outline-text-3" id="text-org893f118">
<p>
Similar to going to the <code>*compilation*</code> buffer and <code>revert-buffer</code>.
But a single command.
</p>
</div>
</div>

<div id="outline-container-org42fa933" class="outline-3">
<h3 id="org42fa933">ansi colors for comint</h3>
<div class="outline-text-3" id="text-org42fa933">
<p>
If you use <a href="https://github.com/lambdaisland/kaocha">Koacha</a> together with <code>compile</code>,
you will get output sprinkled with ANSI (color) escape codes.
</p>

<p>
Bit cluttering on the eyes.
</p>

<p>
I knew from earlier dabblings that there is a package called <code>ansi-color</code>.
So I checked around on how to make my buffer colored nicely.
</p>

<p>
Turns out that <code>comint</code> already has <code>ansi-color-compilation-filter</code> setup by default.
Checking the code for <code>compile</code> I see that with prefix arg, the buffer
becomes a comint buffer.
So I decided I always make my compile buffers comint buffers.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(advice-add
   'compile
   <span style="font-weight: bold;">:filter-args</span>
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/always-use-comint-for-compile</span> (args)
     `(,(car args) t)))
</pre>
</div>

<p>
Koacha output looks like this:
</p>


<div id="org0ff1d83" class="figure">
<p><img src="https://i.imgur.com/5vpmnsu.png" alt="5vpmnsu.png" />
</p>
<p><span class="figure-number">Figure 3: </span>A <code>compile</code> buffer running <code>Koacha</code> with pleasing green colored output text.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdee631b" class="outline-2">
<h2 id="orgdee631b">Levers are great</h2>
<div class="outline-text-2" id="text-orgdee631b">
</div>
<div id="outline-container-org2ad29c2" class="outline-3">
<h3 id="org2ad29c2">ssh</h3>
<div class="outline-text-3" id="text-org2ad29c2">
<p>
Nice tip in case you did not know:
You can define preset configs in <code>~/.ssh/config</code> and they will show up
as bash completions when you type <code>ssh</code>  and hit tap.
</p>

<div class="org-src-container">
<pre class="src src-shell">Host dotomic-system-ec2
     HostName ...
     ...
</pre>
</div>

<p>
So now I just type <code>M-&amp;</code> for <code>async-shell-command</code>, then <code>ssh</code>, then
I hit tap and I get <code>dotomic-system-ec2</code> as completion. Yes!
</p>
</div>
</div>

<div id="outline-container-org47cb68a" class="outline-3">
<h3 id="org47cb68a">embarking</h3>
<div class="outline-text-3" id="text-org47cb68a">
<p>
Through <a href="https://github.com/oantolin/embark">embark</a> the power of completions is further amplified.
For instance, I can complete git branches via <code>git checkout</code> completions.
</p>


<div id="orgd945f87" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/embarking-git-branches.gif?raw=true" alt="embarking-git-branches.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 4: </span>Abusing <code>read-shell-command</code> to dispatch with <code>embark</code> on git checkout completions. Invoking <code>embark-insert</code> as an example.</p>
</div>
</div>
</div>

<div id="outline-container-orgfdf96a1" class="outline-3">
<h3 id="orgfdf96a1">pass</h3>
<div class="outline-text-3" id="text-orgfdf96a1">
<p>
Another example. I used to use <a href="https://github.com/emacs-helm/helm-pass/blob/master/helm-pass.el">helm-pass</a> for <code>pass</code>.
Guess what, <code>pass</code> has great shell completions.
I get a free interface to <code>pass</code> just with <code>async-shell-command</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org2ac6f8c" class="outline-2">
<h2 id="org2ac6f8c">Particulars</h2>
<div class="outline-text-2" id="text-org2ac6f8c">
</div>
<div id="outline-container-org99c2068" class="outline-3">
<h3 id="org99c2068">shell-file-name</h3>
<div class="outline-text-3" id="text-org99c2068">
<p>
It matters.
For instance, if you use "/bin/bash" and you set up your path in a <code>zshrc</code> that might be a pitfall.
Another thing that happened to me was that <a href="https://www.funtoo.org/Funtoo:Keychain">keychain</a> was prompting for my ssh password inside the <code>bash-completion</code> process, making it hang.
</p>
</div>
</div>

<div id="outline-container-org0e57b16" class="outline-3">
<h3 id="org0e57b16">troubleshoot</h3>
<div class="outline-text-3" id="text-org0e57b16">
<ol class="org-ol">
<li>can you start `bash` and have completions? (on arch, maybe you want
to install <code>bash-completion</code>).</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-09-22 Thu 12:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</p>
</div>
</body>
</html>
