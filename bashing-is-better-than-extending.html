<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bashing is better than extending</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Bashing is better than extending</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgdbf20ac">Introduction</a></li>
<li><a href="#org54fc026"><code>read-shell-command</code></a></li>
<li><a href="#org96ed603"><code>shell-command</code>, <code>async-shell-command</code> + friends</a>
<ul>
<li><a href="#org5053149"><code>shell-command</code></a>
<ul>
<li><a href="#org1e6bcb8">Here is a nugget:</a></li>
<li><a href="#org95e0493">Good to know:</a></li>
<li><a href="#org28589a3">Output bufffer</a></li>
</ul>
</li>
<li><a href="#orga9e3694"><code>shell-command-async</code></a></li>
<li><a href="#orgad48c72"><code>compile</code></a></li>
<li><a href="#orgcccaf6a">dired</a></li>
</ul>
</li>
<li><a href="#orgffc825c"><code>bash-completion</code></a></li>
<li><a href="#orgeaf078f">bash completions are now your lever</a></li>
<li><a href="#orgfb4af49"><code>shell-file-name</code></a></li>
<li><a href="#orgdf7598e">babashka tasks</a></li>
<li><a href="#orgb7f4cc9">Lever</a></li>
<li><a href="#org3450e63">async-shell-command and friends</a>
<ul>
<li><a href="#org61f3ae6">compilation</a></li>
<li><a href="#org0b7d336">rerun compilation with a single key</a></li>
</ul>
</li>
<li><a href="#org2870903">default env for your async shell commands</a></li>
<li><a href="#org57f548b">read shell command</a>
<ul>
<li><a href="#orgabb377c">history</a></li>
<li><a href="#orgceb1c3b">make completions even sicker</a></li>
</ul>
</li>
<li><a href="#org9b9835f">histories</a></li>
<li><a href="#orgbebedd2">It gets even better</a></li>
<li><a href="#org22c1d63">project</a></li>
<li><a href="#org39cca03">recompile</a></li>
<li><a href="#orga7f88fd">ansi colors for comint</a></li>
<li><a href="#org5190f2d">Bash completions are your lever</a>
<ul>
<li><a href="#org5ec45ee">ssh</a></li>
<li><a href="#orgcf213fd">embarking</a></li>
</ul>
</li>
<li><a href="#orgdb61c98">story</a></li>
</ul>
</div>
</div>
<p>
How <code>bash-completion</code> makes everything better by enableling power
through general leverage.
Demonstrations of technology around <code>shell-command</code>.
Simplicity and joy with babashka tasks.
</p>


<div id="outline-container-orgdbf20ac" class="outline-2">
<h2 id="orgdbf20ac">Introduction</h2>
<div class="outline-text-2" id="text-orgdbf20ac">
<p>
Ok let just do it. You might want to hold tight to your chair because
the juiciness and elegance of what follow might just blow you over.
Here is how I build my <a href="https://benjamin-asdf.github.io/faster-than-light-memes/">blog</a> with babashka tasks:
</p>



<div id="org7692eec" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/bb-task-demo.gif?raw=true" alt="bb-task-demo.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 1: </span>Using <code>compile</code> to leverage <code>read-shell-command</code> and thereby <code>bash-completions</code>. Recompiling via <code>revert-buffer</code>. Dismissing the <code>*compilation*</code> bufffer.</p>
</div>

<p>
You might think "Ok sure, looks useful." Let me entice you with the
really impressive thing about this:
</p>

<ol class="org-ol">
<li>This is general across all projects, all shell commands where there
is bash completion for it.</li>
<li>The elisp line count that is concretely about babashka tasks in my
config is <code>zero</code>.</li>
<li>The amount of config I have for the faster-than-light-memes project
is <code>zero</code>. It just works by having a <code>bb.edn</code> with tasks.</li>
</ol>




<p>
This is possible by the harmony between some 3 or 4 general tools.
Together they are like layers of ice.
Let me hand you your skates that let you glide on it. Smoothly, gracefully and <b>fast</b>.
</p>

<p>
Let me tell you a story of a few humble builtin emacs commands and a
happy little package called <code>bash-completion</code>.
</p>



<p>
Together they are like
pieces of a machine
rolling precisely
with a layer of ice on the top.
And there are skates available that make you go <b>fast</b>.
</p>

<p>
<a href="https://clojurians.slack.com/archives/C099W16KZ/p1663862976109399">this slack conversation</a>
</p>
</div>
</div>


<div id="outline-container-org54fc026" class="outline-2">
<h2 id="org54fc026"><code>read-shell-command</code></h2>
<div class="outline-text-2" id="text-org54fc026">
<p>
This is like `read-from-minibuffer` but sets some keymap and hstory.
If you type tab, you get completions from <code>shell-dynamic-complete-functions</code>.
</p>

<p>
By default this does something when you start typing a command name,
tab. Or start typing a file name (<code>.</code> also works) and hit tab.
</p>

<p>
In just a bit I introduce the Character of the story that brings in <b>any</b>
shell completions.
</p>
</div>
</div>


<div id="outline-container-org96ed603" class="outline-2">
<h2 id="org96ed603"><code>shell-command</code>, <code>async-shell-command</code> + friends</h2>
<div class="outline-text-2" id="text-org96ed603">
<p>
They use <code>read-shell-command</code>.
</p>
</div>

<div id="outline-container-org5053149" class="outline-3">
<h3 id="org5053149"><code>shell-command</code></h3>
<div class="outline-text-3" id="text-org5053149">
<p>
Bound to <code>M-!</code>
</p>

<p>
This is the <code>interactive</code> doorway into emacs lisp <code>start-process</code> functionality.
It has quite a big doc string.
</p>
</div>

<div id="outline-container-org1e6bcb8" class="outline-4">
<h4 id="org1e6bcb8">Here is a nugget:</h4>
<div class="outline-text-4" id="text-org1e6bcb8">
<blockquote>
<p>
With prefix argument, insert the COMMAND's output at point.
</p>
</blockquote>

<p>
Can be nice, you can do <code>C-u M-!</code> <code>date</code> and you have a date inserted
in the buffer.
</p>
</div>
</div>

<div id="outline-container-org95e0493" class="outline-4">
<h4 id="org95e0493">Good to know:</h4>
<div class="outline-text-4" id="text-org95e0493">
<blockquote>
<p>
If COMMAND ends in &amp;, execute it asynchronously.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org28589a3" class="outline-4">
<h4 id="org28589a3">Output bufffer</h4>
<div class="outline-text-4" id="text-org28589a3">
<p>
Your command output is located by default in a buffer named by <code>shell-command-buffer-name</code>.
Or <code>shell-command-buffer-name-async</code> when async.
</p>
</div>
</div>
</div>

<div id="outline-container-orga9e3694" class="outline-3">
<h3 id="orga9e3694"><code>shell-command-async</code></h3>
<div class="outline-text-3" id="text-orga9e3694">
<p>
Bound to <code>M-&amp;</code> and has the same effect as adding a <code>&amp;</code> in <code>shell-command</code>.
</p>
</div>
</div>

<div id="outline-container-orgad48c72" class="outline-3">
<h3 id="orgad48c72"><code>compile</code></h3>
<div class="outline-text-3" id="text-orgad48c72">
<p>
Very useful, very similar to <code>shell-command-async</code>.
Always uses the same buffer called <code>*compilation*</code>.
You can set <code>compile-command</code> for instance via <code>.dir-locals.el</code>, then
it auto makes a compile command in that project.
</p>
</div>
</div>

<div id="outline-container-orgcccaf6a" class="outline-3">
<h3 id="orgcccaf6a">dired</h3>
<div class="outline-text-3" id="text-orgcccaf6a">
<p>
<code>dired-do-shell-command</code> and <code>dired-do-async-shell-command</code>
are symetrical with <code>shell-command</code> and <code>async-shell-command</code>.
In fact, those functions call <code>shell-command</code>.
</p>

<p>
Bound to <code>!</code> and <code>&amp;</code> in dired.
Docstring is worth reading.
Important to know is that <code>*</code> expands to <code>dired-file-name-at-point</code>,
or the marked files, but is implicit as last arg.
</p>
</div>
</div>
</div>

<div id="outline-container-orgffc825c" class="outline-2">
<h2 id="orgffc825c"><code>bash-completion</code></h2>
<div class="outline-text-2" id="text-orgffc825c">
<p>
Ok so now you know there is some places where you can start an emacs
process via shell command.
</p>

<p>
Let me make your life better: <a href="https://github.com/szermatt/emacs-bash-completion">bash-completion</a>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package bash-completion
  <span style="font-weight: bold;">:init</span> (autoload
          'bash-completion-dynamic-complete
          <span style="font-style: italic;">"bash-completion"</span>
          <span style="font-style: italic;">"BASH completion hook"</span>)
  (add-hook
   'shell-dynamic-complete-functions
   #'bash-completion-dynamic-complete))
</pre>
</div>

<p>
Remember how I said <code>shell-dynamic-complete-functions</code> contribute to
your completions.
</p>

<p>
Here are the completions of your shell at the tips of those sweet
coconut oily fingers.
</p>
</div>
</div>

<div id="outline-container-orgeaf078f" class="outline-2">
<h2 id="orgeaf078f">bash completions are now your lever</h2>
<div class="outline-text-2" id="text-orgeaf078f">
<p>
Now my friends we have entered the realm of harnessing already
existing shell completions directly into our kingdom of emacs that
makes us feel so cozy and at home.
</p>
</div>
</div>








<div id="outline-container-orgfb4af49" class="outline-2">
<h2 id="orgfb4af49"><code>shell-file-name</code></h2>
<div class="outline-text-2" id="text-orgfb4af49">
<p>
Your <code>shell-file-name</code> matters.
I decided "/bin/bash" is just good enough when I am shelling from emacs.
I checked with zsh and it worked fine btw.
</p>
</div>
</div>


<div id="outline-container-orgdf7598e" class="outline-2">
<h2 id="orgdf7598e">babashka tasks</h2>
<div class="outline-text-2" id="text-orgdf7598e">
<p>
Babashka tasks are a great invention of our time,
allowing my to write build tasks in my favority language clojure, with the
development ergonomics of a lisp.
</p>

<p>
The babashka book has <a href="https://book.babashka.org/#_terminal_tab_completion">a section</a> on adding shell completions.
</p>
</div>
</div>



<div id="outline-container-orgb7f4cc9" class="outline-2">
<h2 id="orgb7f4cc9">Lever</h2>
<div class="outline-text-2" id="text-orgb7f4cc9">
<p>
Levers are great.
They make it possible to have a large effect with little
</p>

<p>
effort
output with input
</p>
</div>
</div>


<div id="outline-container-org3450e63" class="outline-2">
<h2 id="org3450e63">async-shell-command and friends</h2>
<div class="outline-text-2" id="text-org3450e63">
<p>
mm/shell-command-on-file
</p>
</div>


<div id="outline-container-org61f3ae6" class="outline-3">
<h3 id="org61f3ae6">compilation</h3>
</div>

<div id="outline-container-org0b7d336" class="outline-3">
<h3 id="org0b7d336">rerun compilation with a single key</h3>
</div>
</div>

<div id="outline-container-org2870903" class="outline-2">
<h2 id="org2870903">default env for your async shell commands</h2>
<div class="outline-text-2" id="text-org2870903">
<p>
enter .dir-locals.el
</p>

<p>
I never remember the syntax to this
Like how it was with `ln` before borkdude shared this trick:
substitute <code>ln</code> with <code>cp</code> in your mind and you know the args.
</p>

<p>
Imagine
you write a list
of function calls
the operation is the mode and is allowed to be nil
the args are variables to set
you write a cons cell in elisp as a dotted list (foo . bar)
</p>

<p>
And imagine there is a quote around your list
</p>
</div>
</div>



<div id="outline-container-org57f548b" class="outline-2">
<h2 id="org57f548b">read shell command</h2>
<div class="outline-text-2" id="text-org57f548b">
</div>
<div id="outline-container-orgabb377c" class="outline-3">
<h3 id="orgabb377c">history</h3>
<div class="outline-text-3" id="text-orgabb377c">
<p>
M-h		consult-history
M-i		completion-at-point
M-n		next-history-element
M-p		previous-history-element
</p>

<p>
M-r		previous-matching-history-element
M-s		next-matching-history-element
</p>



<p>
frankly those are not so useful to me because consult-history coverst that
like a powerhose
like a power hose
like a water hydrant hose
</p>

<p>
M-r		previous-matching-history-element
M-s		next-matching-history-element
</p>
</div>
</div>


<div id="outline-container-orgceb1c3b" class="outline-3">
<h3 id="orgceb1c3b">make completions even sicker</h3>
<div class="outline-text-3" id="text-orgceb1c3b">
<p>
Here is a few pieces that make minibuffer completions
bolster
add levarage
make it juicy
</p>

<p>
I have consult-yank-pop on M-y
</p>

<p>
hippie
it might sometimes just uncannily know what you where thinking
</p>


<p>
(setq-default compile-command "bb tasks")
</p>
</div>
</div>
</div>

<div id="outline-container-org9b9835f" class="outline-2">
<h2 id="org9b9835f">histories</h2>
<div class="outline-text-2" id="text-org9b9835f">
<p>
compile-history
shell-command-history
dired-shell-command-history
</p>
</div>
</div>


<div id="outline-container-orgbebedd2" class="outline-2">
<h2 id="orgbebedd2">It gets even better</h2>
<div class="outline-text-2" id="text-orgbebedd2">
<p>
Let me introduce you to the wonders of <code>revert-buffer-function</code>.
<code>revert-buffer</code> is a powerful command by itself.
</p>


<p>
I did not know this for a while, but you can set the local variable <code>revert-buffer-function</code>.
</p>

<p>
Thanks to this stroke of genius:
</p>

<blockquote>
<p>
5f650422e4a4c44ffc5ee0be4ec969765a307c7b
Author:     Sean Whitton &lt;spwhitton@spwhitton.name&gt;
Set revert-buffer-function in shell command output buffers
</p>
</blockquote>

<p>
This pearl is in emacs 28:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setq-local</span> revert-buffer-function
                              (<span style="font-weight: bold;">lambda</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> _)
                                (async-shell-command command buffer)))
</pre>
</div>

<p>
You say <code>revert-buffer</code> in shell command buffer, to boom run the
command again in the same buffer.
Lol, so good.
</p>
</div>
</div>

<div id="outline-container-org22c1d63" class="outline-2">
<h2 id="org22c1d63">project</h2>
<div class="outline-text-2" id="text-org22c1d63">
<p>
There is a big package <code>projectile</code> that sees wide usage.
Personally I settled on <code>project.el</code>, it was added to emacs a few
years after <code>projectile</code> came out and it vibes more with my aesthetics.
Simpler + builtin + gets everything done I need.
</p>

<p>
Use <code>project-compile</code> to run <code>compile</code> in the project root.
Analogously, there is <code>project-async-shell-command</code>.
<code>projectile</code> provides similar commands.
</p>
</div>
</div>

<div id="outline-container-org39cca03" class="outline-2">
<h2 id="org39cca03">recompile</h2>
<div class="outline-text-2" id="text-org39cca03">
<p>
Similar to going to the <code>*compilation*</code> buffer and <code>revert-buffer</code>.
But a single command.
</p>
</div>
</div>

<div id="outline-container-orga7f88fd" class="outline-2">
<h2 id="orga7f88fd">ansi colors for comint</h2>
<div class="outline-text-2" id="text-orga7f88fd">
<p>
If you use <a href="https://github.com/lambdaisland/kaocha">Koacha</a> together with <code>compile</code>,
you will get output sprinkled with ANSI (color) escape codes.
</p>

<p>
Bit cluttering on the eyes.
</p>

<p>
I knew from earlier dabblelings that there is a package called <code>ansi-color</code>
So I checked around on how to make my buffer colored nicely.
</p>

<p>
Turns out that <code>comint</code> already has <code>ansi-color-compilation-filter</code> setup by default.
Checking the code for <code>compile</code> I see that with prefix arg, the buffer
becomes a comint buffer.
So I decided I always make my compile buffers comint buffers.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(advice-add
   'compile
   <span style="font-weight: bold;">:filter-args</span>
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/always-use-comint-for-compile</span> (args)
     `(,(car args) t)))
</pre>
</div>

<p>
Koacha output looks like this:
</p>

<p>
<a href="https://imgur.com/a/ZiskjEC">https://imgur.com/a/ZiskjEC</a>
</p>
</div>
</div>


<div id="outline-container-org5190f2d" class="outline-2">
<h2 id="org5190f2d">Bash completions are your lever</h2>
<div class="outline-text-2" id="text-org5190f2d">
<p>
A lot of programs on linux come with bash completions.
This is power is just lying around waiting to be picked up.
</p>
</div>

<div id="outline-container-org5ec45ee" class="outline-3">
<h3 id="org5ec45ee">ssh</h3>
<div class="outline-text-3" id="text-org5ec45ee">
<p>
Really nice tip in case you did not know:
You can define preset configs in <code>~/.ssh/config</code> and they will show up
as bash completions when you type <code>ssh</code>  and hit tap.
Here is for example my ssh config to tunnel into a datomic cloud compute group:
</p>

<blockquote>
<p>
Host dotomic-system-ec2
     HostName ec2-xx-xxx-xx-xx.compute-1.amazonaws.com
     User ec2-user
     IdentityFile <i>home/benj</i>.ssh/ben-ec2-key-pair.pem
     LocalForward 7000 ec2-xx-xxx-xx-xx.compute-1.amazonaws.com:7000
</p>
</blockquote>

<p>
(I have a clojure nrepl running at port 7000 there, feels good).
</p>
</div>
</div>

<div id="outline-container-orgcf213fd" class="outline-3">
<h3 id="orgcf213fd">embarking</h3>
<div class="outline-text-3" id="text-orgcf213fd">
<p>
Through <a href="https://github.com/oantolin/embark">embark</a> the reach and hence of completions if further amplified.
For instance, I can complete git branches via <code>git checkout</code> completions.
Embark gives me general actions for completion candidates, so I
can for instance choose to insert the candidate into the buffer.
Of course there is nothing special about git completions, they are
provided via <code>bash-completion</code>.
</p>


<div id="org2052bdf" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/bb-task-demo.gif?raw=true" alt="bb-task-demo.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 2: </span>Abusing <code>read-shell-command</code> to dispatch with <code>embark</code> on git checkout completions. Invoking <code>embark-insert</code> as an example.</p>
</div>
</div>
</div>
</div>





<div id="outline-container-orgdb61c98" class="outline-2">
<h2 id="orgdb61c98">story</h2>
<div class="outline-text-2" id="text-orgdb61c98">
<p>
once upon a time
</p>

<p>
there was a tribe of elves living in a city on a big tree in a magic forest.
They crafted all kinds of beautiful spells, some of them woven into
the fabric of the big forest itself.
</p>

<p>
They could make magc machienes on other trees in the fores burst
into life or freeze forever.
</p>

<p>
Whenever they crafted a spell, they wrote it down in magic books, that
happened to be the magic system of the forest
</p>


<p>
instructions where converted into the
</p>

<p>
when you built a spell that reached into another part of the forest,
</p>

<p>
you crafted a beautiful book that told a story about that part of the forest.
About how to reach that place of magic, and about the animals that lived there.
</p>

<p>
The language was so beautiful and easy to use that the elves did not
notice
</p>

<p>
One day a crafty hacker
</p>

<p>
magic mirror of ice
it has become a sport to ride on the ice
such was the magic of the mirror that you could make spells inside the castle
just crazing on the ice. And this was blazingly fast.
</p>

<p>
The book of the mirror then, was a sort of book of books that allowed
the casting of spells without the need for more books.
</p>

<p>
Among the high scholars of the elves
</p>

<p>
there emerged a growing consensus that the writing of more and more books
</p>

<p>
that there must be some escence
that is captured by an even cleverer book.
</p>

<p>
The queen decreed that whomever finds a clever book of books
wins a price and the highest honors.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-09-22 Thu 12:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.0.50 (<a href="https://orgmode.org">Org</a> mode 9.5.4)</p>
</div>
</body>
</html>
