<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bashing is better than extending</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Bashing is better than extending</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgce23f5d">Introduction</a></li>
<li><a href="#orgb51e1aa">Emacs in a magic forest</a></li>
<li><a href="#org189e411">read-shell-command</a></li>
<li><a href="#org471894b">bash-completion</a></li>
<li><a href="#org1080f14">bash completions are now your lever</a>
<ul>
<li><a href="#org9dd7195">Babashka tasks</a></li>
</ul>
</li>
<li><a href="#org9bd9f8a">Commands that leverage <code>read-shell-command</code></a>
<ul>
<li><a href="#orgf48fa76">shell-command</a>
<ul>
<li><a href="#org9989cce">Here is a nugget:</a></li>
<li><a href="#orgddedf8f">Good to know:</a></li>
<li><a href="#org54de924">Output buffer</a></li>
</ul>
</li>
<li><a href="#orgbde0a54">shell-command-async</a></li>
<li><a href="#org744478d">compile</a></li>
<li><a href="#orgc5c63de">dired</a></li>
<li><a href="#orgfbcf05c">shell-command-on-file</a></li>
</ul>
</li>
<li><a href="#org963a79f">It gets even better</a>
<ul>
<li><a href="#org7968ce3">revert-buffer in compilation buffers</a></li>
</ul>
</li>
<li><a href="#org64cab9a">Scripts at the speed of thought</a>
<ul>
<li><a href="#orgf48b317">mememacs/create-script</a>
<ul>
<li><a href="#orgbbc8693">bash-completion in <code>sh-mode</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge25b595">async-shell-command, my bread and butter</a>
<ul>
<li><a href="#orga93ede5">Put the command into the buffer name</a></li>
<li><a href="#org8a91817">shell-command&#x2013;same-buffer-confirm</a></li>
<li><a href="#org26ed96c">shell-mode as a terminal emulator</a></li>
</ul>
</li>
<li><a href="#org0989d1c">process-list</a></li>
<li><a href="#org66ffacd">The next layer on the cake</a>
<ul>
<li><a href="#org5b91295">project</a></li>
<li><a href="#org5a4a514">recompile</a></li>
<li><a href="#org105944e">ansi colors for comint</a></li>
</ul>
</li>
<li><a href="#orgc50e828">Levers are great</a>
<ul>
<li><a href="#orgab6be3f">ssh</a></li>
<li><a href="#org09ecc54">embarking</a></li>
<li><a href="#org485419e">pass</a></li>
</ul>
</li>
<li><a href="#org5dd7d30">Particulars</a>
<ul>
<li><a href="#orgd858532">shell-file-name</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<b>Not</b> how to run babashka tasks.
</p>

<p>
How <code>bash-completion</code>  makes everything better.
</p>

<p>
How to run <b>any</b> shell commands.
</p>

<p>
Technology around <code>shell-command</code>.
</p>

<p>
Simplicity and joy.
</p>

<div id="outline-container-orgce23f5d" class="outline-2">
<h2 id="orgce23f5d">Introduction</h2>
<div class="outline-text-2" id="text-orgce23f5d">
<p>
Ok, let's just do it. You might want to hold tight to your chair because
the juiciness and elegance of what follow might just blow you over.
Here is how I build my <a href="https://benjamin-asdf.github.io/faster-than-light-memes/">blog</a> with babashka tasks:
</p>


<div id="orgb657ec5" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/bb-task-demo.gif?raw=true" alt="bb-task-demo.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 1: </span>Using <code>compile</code> to leverage <code>read-shell-command</code> and thereby <code>bash-completions</code>. Recompiling via <code>revert-buffer</code>. Dismissing the <code>*compilation*</code> buffer.</p>
</div>

<p>
You might think "Ok sure, looks useful." Let me entice you with the
the really impressive thing about this:
</p>

<p>
There is nothing concrete about babashka tasks nor about that specific
project in my emacs config.
It just works by having a <code>bb.edn</code> with tasks.
</p>

<p>
Made possible via the harmony between some 3 or 4 general tools.
Like layers of ice. You deserve some skates to ride on
it. Smoothly, gracefully and <b>fast</b>.
Here is the story of a happy little package called <code>bash-completion</code>.
</p>
</div>
</div>

<div id="outline-container-orgb51e1aa" class="outline-2">
<h2 id="orgb51e1aa">Emacs in a magic forest</h2>
<div class="outline-text-2" id="text-orgb51e1aa">
<p>
Once upon a time,
</p>

<p>
there was an elven city on a big tree called Emacs in a magic forest.
They crafted all kinds of beautiful spells, some of them woven into
the fabric of the big forest itself.
</p>

<p>
A spell was crafted by writing in a magic book.
The language in the books was extremely pithy and made heavy use of parenthesis.
</p>

<p>
The city was overflowing with books. Even though the elves had
mastered the technology of infinite storage space, it was considered bad style to
produce more books as was necessary.
There were little books everywhere that talked about every corner of the forest.
Every time an elf wanted to craft a spell that had an effect somewhere
else in the forest, they would make a spell that talked to the river
and roots (called <code>shell</code> for some reason) in a language of <code>commands</code>.
</p>

<p>
The elves especially treasured their books <code>orderless</code>, <code>vetico</code> and
<code>consult</code>, though anything that made <code>completing-read</code> beautiful and
effective worked (<code>helm</code>, <code>ivy</code>, <code>selectrum</code>).
</p>

<p>
All elves knew well how to select <code>candidates</code> <b>fast</b>.
So it became really useful to be good at <code>completing-read</code>.
</p>

<p>
One day a hacker elf had an idea for a clever <a href="https://github.com/szermatt/emacs-bash-completion">book</a>.
A spell that would ask the <code>shell</code> for a list of <b><b>candidates of commands</b></b>
By doing so they enabled all <code>commands</code> to be part
of the beautiful dance of emacs, without the need for any more books.
No matter how large the forest grew, a single book would suffice to
make magic in <b>all</b> its corners <b>fast</b>.
</p>
</div>
</div>

<div id="outline-container-org189e411" class="outline-2">
<h2 id="org189e411">read-shell-command</h2>
<div class="outline-text-2" id="text-org189e411">
<p>
This is like <code>read-from-minibuffer</code> but sets some keymap and history.
Hit <code>&lt;tab&gt;</code>, you get completions from <code>shell-dynamic-complete-functions</code>.
Those completions are sort of okay, but they do not give you command-specific completions.
Invoke <code>shell-command</code>, then type <code>git checkout</code>, hit tab. Nothing happens. <b><b>Yet</b></b>.
</p>
</div>
</div>

<div id="outline-container-org471894b" class="outline-2">
<h2 id="org471894b">bash-completion</h2>
<div class="outline-text-2" id="text-org471894b">
<p>
Ok your emacs life is about to level up +1 <a href="https://github.com/szermatt/emacs-bash-completion">bash-completion</a>.
Config:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package bash-completion
  <span style="font-weight: bold;">:init</span> (autoload
          'bash-completion-dynamic-complete
          <span style="font-style: italic;">"bash-completion"</span>
          <span style="font-style: italic;">"BASH completion hook"</span>)
  (add-hook
   'shell-dynamic-complete-functions
   #'bash-completion-dynamic-complete))
</pre>
</div>

<p>
Here are the completions of your shell at the tips of those sweet
coconut oily fingers.
</p>

<p>
Now you can do <code>shell-command</code>
-&gt; Hit that tab while typing <code>git checkout ..</code> a door just
opened.
</p>
</div>
</div>

<div id="outline-container-org1080f14" class="outline-2">
<h2 id="org1080f14">bash completions are now your lever</h2>
<div class="outline-text-2" id="text-org1080f14">
<p>
Now my friends we have entered the realm of harnessing already
existing shell completions directly into our kingdom of emacs where
we cozy and effective.
</p>
</div>

<div id="outline-container-org9dd7195" class="outline-3">
<h3 id="org9dd7195">Babashka tasks</h3>
<div class="outline-text-3" id="text-org9dd7195">
<p>
Babashka tasks are one of the great discoveries of our time,
allowing us to write build tasks in Clojure, with the
development ergonomics of a lisp.
</p>

<p>
The babashka book has <a href="https://book.babashka.org/#_terminal_tab_completion">a section</a> on adding shell completions.
Boom. This is all you need.
Now you can enjoy those babashka tasks completions.
</p>
</div>
</div>
</div>

<div id="outline-container-org9bd9f8a" class="outline-2">
<h2 id="org9bd9f8a">Commands that leverage <code>read-shell-command</code></h2>
<div class="outline-text-2" id="text-org9bd9f8a">
<p>
They use <code>read-shell-command</code>.
Making <code>read-shell-command</code> <b>good</b> will pay off for all these.
</p>
</div>

<div id="outline-container-orgf48fa76" class="outline-3">
<h3 id="orgf48fa76">shell-command</h3>
<div class="outline-text-3" id="text-orgf48fa76">
<p>
Bound to <code>M-!</code>
</p>

<p>
This is the <code>interactive</code> doorway into emacs lisp <code>start-process</code> functionality.
</p>
</div>

<div id="outline-container-org9989cce" class="outline-4">
<h4 id="org9989cce">Here is a nugget:</h4>
<div class="outline-text-4" id="text-org9989cce">
<blockquote>
<p>
With prefix argument, insert the COMMAND's output at point.
</p>
</blockquote>

<p>
<code>C-u M-!</code> <code>date</code> and you have a date inserted in the buffer.
</p>

<p>
Like this:
<code>Thu Sep 29 10:55:44 AM CEST 2022</code>
</p>
</div>
</div>

<div id="outline-container-orgddedf8f" class="outline-4">
<h4 id="orgddedf8f">Good to know:</h4>
<div class="outline-text-4" id="text-orgddedf8f">
<blockquote>
<p>
If COMMAND ends in &amp;, execute it asynchronously.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org54de924" class="outline-4">
<h4 id="org54de924">Output buffer</h4>
<div class="outline-text-4" id="text-org54de924">
<p>
Your command output is located by default in a buffer named by <code>shell-command-buffer-name</code>.
Or <code>shell-command-buffer-name-async</code> when async.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbde0a54" class="outline-3">
<h3 id="orgbde0a54">shell-command-async</h3>
<div class="outline-text-3" id="text-orgbde0a54">
<p>
Bound to <code>M-&amp;</code> and has the same effect as adding a <code>&amp;</code> in <code>shell-command</code>.
To kill the process I can hit <code>C-c C-c</code>.
</p>
</div>
</div>

<div id="outline-container-org744478d" class="outline-3">
<h3 id="org744478d">compile</h3>
<div class="outline-text-3" id="text-org744478d">
<p>
Very useful, very similar to <code>shell-command-async</code>.
Always uses the same buffer called <code>*compilation*</code>.
You can set <code>compile-command</code> for instance via <code>.dir-locals.el</code>, then
it auto makes a compile command in that project.
</p>
</div>
</div>

<div id="outline-container-orgc5c63de" class="outline-3">
<h3 id="orgc5c63de">dired</h3>
<div class="outline-text-3" id="text-orgc5c63de">
<p>
<code>dired-do-shell-command</code> and <code>dired-do-async-shell-command</code>
are symetrical with <code>shell-command</code> and <code>async-shell-command</code>.
Those functions call <code>shell-command</code>.
</p>

<p>
Bound to <code>!</code> and <code>&amp;</code> in dired Docstring is worth reading.
Important to know is that <code>*</code> expands to <code>dired-file-name-at-point</code>,
or the marked files, but is implicit as the last arg.
</p>
</div>
</div>

<div id="outline-container-orgfbcf05c" class="outline-3">
<h3 id="orgfbcf05c">shell-command-on-file</h3>
<div class="outline-text-3" id="text-orgfbcf05c">
<p>
Sometimes you are currently visiting a script file and you just want
to run it.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/shell-command-on-file</span> (command)
  <span style="font-style: italic;">"Execute COMMAND asynchronously on the current file."</span>
  (<span style="font-weight: bold;">interactive</span> (list (read-shell-command
                      (concat <span style="font-style: italic;">"Async shell command on "</span> (buffer-name) <span style="font-style: italic;">": "</span>))))
  (<span style="font-weight: bold;">let</span> ((filename (<span style="font-weight: bold;">if</span> (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (async-shell-command (concat command <span style="font-style: italic;">" "</span> filename))))
</pre>
</div>

<p>
Thanks to <a href="https://github.com/Gavinok/emacs.d">Gavin Freeborn</a> for the initial version of this code.
</p>
</div>
</div>
</div>

<div id="outline-container-org963a79f" class="outline-2">
<h2 id="org963a79f">It gets even better</h2>
<div class="outline-text-2" id="text-org963a79f">
<p>
Let me introduce you to the wonders of <code>revert-buffer-function</code>.
Now, <code>revert-buffer</code> is a powerful command by itself.
</p>

<p>
I did not know this for a while, but you can set the local variable <code>revert-buffer-function</code>.
This pearl is in emacs 28:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setq-local</span>
 revert-buffer-function
 (<span style="font-weight: bold;">lambda</span> (<span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> _)
   (async-shell-command command buffer)))
</pre>
</div>

<p>
You say <code>revert-buffer</code> in a shell command buffer, to boom run the
command again in the same buffer. Exactly what I want sometimes.
A single key to rerun a command. And I think the concepts just fit
nicely. There is no mental burden with this.
</p>
</div>

<div id="outline-container-org7968ce3" class="outline-3">
<h3 id="org7968ce3">revert-buffer in compilation buffers</h3>
<div class="outline-text-3" id="text-org7968ce3">
<div class="org-src-container">
<pre class="src src-elisp">(advice-add
   #'compilation-revert-buffer
   <span style="font-weight: bold;">:filter-args</span>
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/always-noconfirm-compilation-revert-buffer</span> (args)
     (<span style="font-weight: bold;">pcase</span> args
       (`(,ignore-auto nil) `(,ignore-auto t))
       (_ args))))
</pre>
</div>

<p>
I use <code>revert-buffer</code> as a consenting adult - kill and restart the
compile command, without asking.
</p>
</div>
</div>
</div>


<div id="outline-container-org64cab9a" class="outline-2">
<h2 id="org64cab9a">Scripts at the speed of thought</h2>
<div class="outline-text-2" id="text-org64cab9a">

<div id="org45f8216" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/insta-script.gif?raw=true" alt="insta-script.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 2: </span>Make a script, and run the script. Leveraging <code>bash-completion</code> in <code>shell-script-mode</code>.</p>
</div>
</div>

<div id="outline-container-orgf48b317" class="outline-3">
<h3 id="orgf48b317">mememacs/create-script</h3>
<div class="outline-text-3" id="text-orgf48b317">
<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-script*</span> (file bang setup)
  (find-file file)
  (insert bang)
  (save-buffer)
  (evil-insert-state)
  (set-file-modes file #o751)
  (funcall setup))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-script</span> (file)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"Fnew script: "</span>)
  (mememacs/create-script*
   file
   <span style="font-style: italic;">"#!/bin/sh\n"</span>
   #'shell-script-mode))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/create-bb-script</span> (file)
  (<span style="font-weight: bold;">interactive</span> <span style="font-style: italic;">"Fnew bb: "</span>)
  (mememacs/create-script*
   file
   <span style="font-style: italic;">"#!/usr/bin/env bb\n"</span>
   #'clojure-mode))
</pre>
</div>

<p>
I have bound these in <code>dired-mode</code>.
Then, I use <code>mm/shell-command-on-file</code> to dev interactively sort of.
</p>

<p>
Btw <code>shell-script-mode</code> becomes a power house when you integrate <a href="https://github.com/koalaman/shellcheck">shellcheck</a>.
<code>flycheck</code> has something for that. (pretty sure <code>flymake</code> should as well.)
Shellcheck makes superb warnings. Firmly in my "adopt" circle.
</p>
</div>

<div id="outline-container-orgbbc8693" class="outline-4">
<h4 id="orgbbc8693">bash-completion in <code>sh-mode</code></h4>
<div class="outline-text-4" id="text-orgbbc8693">
<p>
Here is my full <code>bash-completion</code> config that adds to <code>capf</code>.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package bash-completion
  <span style="font-weight: bold;">:init</span>
  (autoload 'bash-completion-dynamic-complete
    <span style="font-style: italic;">"bash-completion"</span>
    <span style="font-style: italic;">"BASH completion hook"</span>)
  (add-hook 'shell-dynamic-complete-functions
            #'bash-completion-dynamic-complete)

  <span style="font-weight: bold;">:config</span>
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-capf-1</span> (bol)
    (bash-completion-dynamic-complete-nocomint (funcall bol) (point) t))
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-eshell-capf</span> ()
    (bash-completion-capf-1 (<span style="font-weight: bold;">lambda</span> () (<span style="font-weight: bold;">save-excursion</span> (eshell-bol) (point)))))
  (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">bash-completion-capf</span> ()
    (bash-completion-capf-1 #'point-at-bol))
  (add-hook
   'sh-mode-hook
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/add-bash-completion</span> ()
     (add-hook 'completion-at-point-functions #'bash-completion-capf nil t))))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge25b595" class="outline-2">
<h2 id="orge25b595">async-shell-command, my bread and butter</h2>
<div class="outline-text-2" id="text-orge25b595">
<p>
Of these commands, it is the one I use the most.
And really, all the other commands could be performed in terms of it.
Here is some of my journey of smoothing out some edges.
</p>
</div>

<div id="outline-container-orga93ede5" class="outline-3">
<h3 id="orga93ede5">Put the command into the buffer name</h3>
<div class="outline-text-3" id="text-orga93ede5">
<p>
When you run a second command, by default, it tries to reuse the old buffer and asks you
</p>

<div class="org-src-container">
<pre class="src src-elisp">(yes-or-no-p
             (format <span style="font-style: italic;">"A command is running in the default buffer.  %s? "</span>
                     action))
</pre>
</div>

<p>
I put the <code>command</code> into the buffer name so I usually get a unique
buffer name.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/put-command-in-async-buff-name</span> (f <span style="font-weight: bold; text-decoration: underline;">&amp;rest</span> args)
  (<span style="font-weight: bold;">let*</span> ((path-s (path-slug default-directory))
         (command (car args))
         (buffname (concat path-s <span style="font-style: italic;">" "</span> command))
         (shell-command-buffer-name-async
          (format
           <span style="font-style: italic;">"*async-shell-command %s*"</span>
           (string-trim
            (substring buffname 0 (min (length buffname) 50))))))
    (apply f args)))

(advice-add 'shell-command <span style="font-weight: bold;">:around</span> #'mm/put-command-in-async-buff-name)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">path-slug</span> (dir)
    <span style="font-style: italic;">"Returns the initials of `dir`s path,</span>
<span style="font-style: italic;">with the last part appended fully</span>

<span style="font-style: italic;">Example:</span>

<span style="font-style: italic;">(path-slug \"/foo/bar/hello\")</span>
<span style="font-style: italic;">=&gt; \"f/b/hello\" "</span>
    (<span style="font-weight: bold;">require</span> '<span style="font-weight: bold; text-decoration: underline;">dash</span>)
    (<span style="font-weight: bold;">let*</span> ((path (replace-regexp-in-string <span style="font-style: italic;">"\\."</span> <span style="font-style: italic;">""</span> dir))
           (path (split-string path <span style="font-style: italic;">"/"</span> t))
           (path-s (mapconcat
                    (<span style="font-weight: bold;">lambda</span> (it)
                      (cl-subseq it 0 1))
                    (-drop-last 1 path)
                    <span style="font-style: italic;">"/"</span>))
           (path-s (concat
                    path-s
                    <span style="font-style: italic;">"/"</span>
                    (-last-item path))))
      path-s))
</pre>
</div>

<p>
Now I can complete buffers and start typing the commands.
And the buffers don't have an anonymous name like <code>*async-shell-command&lt;2&gt;*</code>.
</p>
</div>
</div>

<div id="outline-container-org8a91817" class="outline-3">
<h3 id="org8a91817">shell-command&#x2013;same-buffer-confirm</h3>
<div class="outline-text-3" id="text-org8a91817">
<p>
Sort of a power setting when you do <code>async-shell-command</code> a lot.
I used to have this to <code>'confirm-kill-process</code>
Now I do
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">setf</span> async-shell-command-buffer 'new-buffer)
</pre>
</div>

<p>
If I want to kill I can do <code>C-c C-c</code> on the old buffer.
</p>
</div>
</div>

<div id="outline-container-org26ed96c" class="outline-3">
<h3 id="org26ed96c">shell-mode as a terminal emulator</h3>
<div class="outline-text-3" id="text-org26ed96c">
<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/shell-via-async-shell-command</span> ()
    (switch-to-buffer
     (window-buffer
      (async-shell-command
       shell-file-name))))
</pre>
</div>

<p>
You get a shell buffer running your shell.
Does everything I need from a terminal.
It pays of having a minimal <code>.rc</code> file. This is also why I have
<code>shell-file-name</code> set to "/bin/bash".
Even though I have a cool zsh config with vi mode.
I get all the evil stuff for free in <code>shell</code> buffers.
</p>
</div>
</div>
</div>

<div id="outline-container-org0989d1c" class="outline-2">
<h2 id="org0989d1c">process-list</h2>
<div class="outline-text-2" id="text-org0989d1c">
<p>
You get a list of all current processes.
Here is a function I have bound in <code>process-menu-mode-map</code> :
</p>

<div class="org-src-container">
<pre class="src src-elisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mememacs/process-menu-switch-to-buffer</span> ()
  (<span style="font-weight: bold;">interactive</span>)
  (<span style="font-weight: bold;">when-let*</span>
      ((id (tabulated-list-get-id))
       (b (process-buffer id)))
    (switch-to-buffer b)))
</pre>
</div>

<p>
Nice, a way to easily get to the buffer again when looking at <code>process-list</code>.
</p>

<p>
Similarly useful is doing <code>ibuffer</code> then <code>s m</code> <code>ibuffer-filter-by-used-mode</code> -&gt; <code>shell</code>.
Nice, an ibuffer list of shell procs.
</p>

<p>
With <code>embark</code> I can also do <code>consult-buffer</code> -&gt; <code>b</code> to narrow -&gt; type
<code>async</code> -&gt; <code>embark-export</code>.
Hehe, a nice <code>ibuffer</code> of all my shell commands.
</p>

<p>
If you don't know <code>ibuffer</code>, but you know <code>dired</code>.
Then you know <code>ibuffer</code>. They are analogous by design.
</p>
</div>
</div>

<div id="outline-container-org66ffacd" class="outline-2">
<h2 id="org66ffacd">The next layer on the cake</h2>
<div class="outline-text-2" id="text-org66ffacd">
<p>
More context for <code>shell-command</code>.
</p>
</div>

<div id="outline-container-org5b91295" class="outline-3">
<h3 id="org5b91295">project</h3>
<div class="outline-text-3" id="text-org5b91295">
<p>
I use <code>project.el</code>. <code>project-compile</code>  runs <code>compile</code> in the project root. Analogously, there is <code>project-async-shell-command</code>.
<code>projectile</code>, a big and widely used package, provides similar commands.
</p>
</div>
</div>

<div id="outline-container-org5a4a514" class="outline-3">
<h3 id="org5a4a514">recompile</h3>
<div class="outline-text-3" id="text-org5a4a514">
<p>
Similar to going to the <code>*compilation*</code> buffer and <code>revert-buffer</code>.
But a single command.
</p>
</div>
</div>

<div id="outline-container-org105944e" class="outline-3">
<h3 id="org105944e">ansi colors for comint</h3>
<div class="outline-text-3" id="text-org105944e">
<p>
If you use <a href="https://github.com/lambdaisland/kaocha">Koacha</a> together with <code>compile</code>,
you will get output sprinkled with ANSI (color) escape codes.
</p>

<p>
Bit cluttering on the eyes.
</p>

<p>
I knew from earlier dabblings that there is a package called <code>ansi-color</code>.
So I checked around on how to make my buffer colored nicely.
</p>

<p>
Turns out that <code>comint</code> already has <code>ansi-color-compilation-filter</code> setup by default.
Checking the code for <code>compile</code> I see that with prefix arg, the buffer
becomes a comint buffer.
So I decided I always make my compile buffers comint buffers.
</p>

<div class="org-src-container">
<pre class="src src-elisp">(advice-add
   'compile
   <span style="font-weight: bold;">:filter-args</span>
   (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">mm/always-use-comint-for-compile</span> (args)
     `(,(car args) t)))
</pre>
</div>

<p>
Koacha output looks like this:
</p>


<div id="orgd041702" class="figure">
<p><img src="https://i.imgur.com/5vpmnsu.png" alt="5vpmnsu.png" />
</p>
<p><span class="figure-number">Figure 3: </span>A <code>compile</code> buffer running <code>Koacha</code> with pleasing green colored output text.</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc50e828" class="outline-2">
<h2 id="orgc50e828">Levers are great</h2>
<div class="outline-text-2" id="text-orgc50e828">
</div>
<div id="outline-container-orgab6be3f" class="outline-3">
<h3 id="orgab6be3f">ssh</h3>
<div class="outline-text-3" id="text-orgab6be3f">
<p>
Nice tip in case you did not know:
You can define preset configs in <code>~/.ssh/config</code> and they will show up
as bash completions when you type <code>ssh</code>  and hit tap.
</p>

<div class="org-src-container">
<pre class="src src-shell">Host dotomic-system-ec2
     HostName ...
     ...
</pre>
</div>

<p>
So now I just type <code>M-&amp;</code> for <code>async-shell-command</code>, then <code>ssh</code>, then
I hit tap and I get <code>dotomic-system-ec2</code> as completion. Yes!
</p>
</div>
</div>

<div id="outline-container-org09ecc54" class="outline-3">
<h3 id="org09ecc54">embarking</h3>
<div class="outline-text-3" id="text-org09ecc54">
<p>
Through <a href="https://github.com/oantolin/embark">embark</a> the power of completions is further amplified.
For instance, I can complete git branches via <code>git checkout</code> completions.
</p>


<div id="org163a59e" class="figure">
<p><img src="https://github.com/benjamin-asdf/faster-than-light-memes/blob/master/assets/embarking-git-branches.gif?raw=true" alt="embarking-git-branches.gif?raw=true" />
</p>
<p><span class="figure-number">Figure 4: </span>Abusing <code>read-shell-command</code> to dispatch with <code>embark</code> on git checkout completions. Invoking <code>embark-insert</code> as an example.</p>
</div>
</div>
</div>

<div id="outline-container-org485419e" class="outline-3">
<h3 id="org485419e">pass</h3>
<div class="outline-text-3" id="text-org485419e">
<p>
Another example. I used to use <a href="https://github.com/emacs-helm/helm-pass/blob/master/helm-pass.el">helm-pass</a> for <code>pass</code>.
Guess what, <code>pass</code> has great shell completions.
I get a free interface to <code>pass</code> just with <code>async-shell-command</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org5dd7d30" class="outline-2">
<h2 id="org5dd7d30">Particulars</h2>
<div class="outline-text-2" id="text-org5dd7d30">
</div>
<div id="outline-container-orgd858532" class="outline-3">
<h3 id="orgd858532">shell-file-name</h3>
<div class="outline-text-3" id="text-orgd858532">
<p>
It matters.
For instance, if you use "/bin/bash" and you set up your path in a <code>zshrc</code> that might be a pitfall.
Another thing that happened to me was that <a href="https://www.funtoo.org/Funtoo:Keychain">keychain</a> was prompting for my ssh password inside the <code>bash-completion</code> process, making it hang.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-09-22 Thu 12:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.1 (<a href="https://orgmode.org">Org</a> mode 9.5.2)</p>
</div>
</body>
</html>
